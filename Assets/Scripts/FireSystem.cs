using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Transforms;

[UpdateInGroup(typeof(SimulationSystemGroup))]
[BurstCompile]
public partial struct FireSystem : ISystem
{
    private EntityQuery _monsterQuery;

    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
        state.RequireForUpdate<MonsterSpatialSingleton>();
        state.RequireForUpdate<BeginSimulationEntityCommandBufferSystem.Singleton>();
    }

    [BurstCompile]
    public void OnUpdate(ref SystemState state)
    {
        var spatialSingleton = SystemAPI.GetSingleton<MonsterSpatialSingleton>();
        var monsterPositions = spatialSingleton.SortedMonsters.AsArray();
        
        if (monsterPositions.Length == 0) return;

        var ecb = SystemAPI.GetSingleton<BeginSimulationEntityCommandBufferSystem.Singleton>().CreateCommandBuffer(state.WorldUnmanaged);
        float dt = SystemAPI.Time.DeltaTime;
        float currTime = (float)SystemAPI.Time.ElapsedTime;

        // --- 1. Default Range ---
        foreach (var (st, rng, tr, ft, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack, AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt; 
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new SingleDamageRequest { Damage = st.ValueRO.Damage, TargetEntity = tE, ImpactPosition = tP, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (rng.ValueRO.MaxRange / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        foreach (var (st, rng, tr, ft, pool, bfr, aoe, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>, RefRO<AoEHitAttack>>().WithAll<AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new AoEDamageRequest { Damage = st.ValueRO.Damage, TargetPosition = tP, Radius = aoe.ValueRO.AoERadius, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (rng.ValueRO.MaxRange / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeDefault>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float rSq = rng.ValueRO.MaxRange * rng.ValueRO.MaxRange; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        // --- 2. Sector Range ---
        foreach (var (st, rng, tr, ft, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack, AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new SingleDamageRequest { Damage = st.ValueRO.Damage, TargetEntity = tE, ImpactPosition = tP, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (maxR / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        foreach (var (st, rng, tr, ft, pool, bfr, aoe, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>, RefRO<AoEHitAttack>>().WithAll<AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new AoEDamageRequest { Damage = st.ValueRO.Damage, TargetPosition = tP, Radius = aoe.ValueRO.AoERadius, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (maxR / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeSector>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 fwd = math.forward(st.ValueRO.LogicalRotation); float hAng = math.radians(rng.ValueRO.Angle) * 0.5f; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float2 f2 = math.normalize(new float2(fwd.x, fwd.z)); float maxR = rng.ValueRO.MaxRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float2 mP = new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z); float d = math.distancesq(p2, mP); if (d <= nD) { if (math.acos(math.clamp(math.dot(f2, math.normalize(mP - p2)), -1f, 1f)) <= hAng) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        // --- 3. Annulus Range ---
        foreach (var (st, rng, tr, ft, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack, AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new SingleDamageRequest { Damage = st.ValueRO.Damage, TargetEntity = tE, ImpactPosition = tP, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (maxR / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        foreach (var (st, rng, tr, ft, pool, bfr, aoe, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>, RefRO<AoEHitAttack>>().WithAll<AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new AoEDamageRequest { Damage = st.ValueRO.Damage, TargetPosition = tP, Radius = aoe.ValueRO.AoERadius, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * (maxR / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeAnnulus>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float2 p2 = new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z); float maxR = rng.ValueRO.MaxRange; float minRSq = rng.ValueRO.MinRange * rng.ValueRO.MinRange; float rSq = maxR * maxR; int idx = BinarySearchX(monsterPositions, tr.ValueRO.Position.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - tr.ValueRO.Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = tr.ValueRO.Position.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(p2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d >= minRSq && d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(p2, new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        // --- 4. Offset Range ---
        foreach (var (st, rng, tr, ft, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack, AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new SingleDamageRequest { Damage = st.ValueRO.Damage, TargetEntity = tE, ImpactPosition = tP, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z), new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * ((rng.ValueRO.MaxRange + rng.ValueRO.AttackRadius) / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<SingleHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z), new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = tE, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = false }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }

        foreach (var (st, rng, tr, ft, pool, bfr, aoe, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>, RefRO<AoEHitAttack>>().WithAll<AttackHitData>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { Entity m = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(m, LocalTransform.FromPosition(tr.ValueRO.Position)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = m }); ecb.AddComponent(m, new AoEDamageRequest { Damage = st.ValueRO.Damage, TargetPosition = tP, Radius = aoe.ValueRO.AoERadius, TowerEntity = tower }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackDirectData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z), new float2(tP.x, tP.z)); float spd = att.ValueRO.Speed * ((rng.ValueRO.MaxRange + rng.ValueRO.AttackRadius) / math.max(dst, 0.1f)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = spd, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Direct, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = spd, Length = dst, Height = 0f }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
        foreach (var (st, rng, tr, ft, att, pool, bfr, tower) in SystemAPI.Query<RefRW<TowerStats>, RefRO<TowerRangeOffset>, RefRW<LocalTransform>, RefRW<TowerFireTime>, RefRO<AttackProjectileData>, RefRW<TowerBulletPool>, DynamicBuffer<TowerBulletElement>>().WithAll<AoEHitAttack>().WithEntityAccess()) {
            float dly = 1f / st.ValueRO.AttackSpeed; st.ValueRW.AttackTimer -= dt;
            float3 tP = default; Entity tE = Entity.Null; bool fd = false; float3 wO = math.rotate(st.ValueRO.LogicalRotation, rng.ValueRO.Offset); float3 aC = tr.ValueRO.Position + new float3(wO.x, 0, wO.z); float2 c2 = new float2(aC.x, aC.z); float rad = rng.ValueRO.AttackRadius; float rSq = rad * rad; int idx = BinarySearchX(monsterPositions, aC.x); float nD = rSq;
            for (int i = idx; i < monsterPositions.Length; i++) { float dx = monsterPositions[i].Position.x - aC.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            for (int i = idx - 1; i >= 0; i--) { float dx = aC.x - monsterPositions[i].Position.x; if (dx * dx > rSq) break; float d = math.distancesq(c2, new float2(monsterPositions[i].Position.x, monsterPositions[i].Position.z)); if (d <= nD) { nD = d; tP = monsterPositions[i].Position; tE = monsterPositions[i].Entity; fd = true; } }
            if (fd) { if (st.ValueRO.Rotationable) tr.ValueRW.Rotation = quaternion.LookRotationSafe(math.normalize(tP - tr.ValueRO.Position), math.up()); if (st.ValueRO.AttackTimer <= 0) { var aoe = SystemAPI.GetComponent<AoEHitAttack>(tower); Entity b = bfr[pool.ValueRW.CurrentIndex % bfr.Length].Value; pool.ValueRW.CurrentIndex++; ecb.SetComponent(b, LocalTransform.FromPositionRotation(tr.ValueRO.Position, tr.ValueRO.Rotation)); ecb.AppendToBuffer(tower, new MuzzleVFXPlayRequest { VfxEntity = b }); float dst = math.distance(new float2(tr.ValueRO.Position.x, tr.ValueRO.Position.z), new float2(tP.x, tP.z)); ecb.SetComponent(b, new BulletData { StartPos = tr.ValueRO.Position, EndPos = tP, Speed = att.ValueRO.Speed, Damage = st.ValueRO.Damage, TargetEntity = Entity.Null, TowerEntity = tower, AttackType = TowerAttackType.Projectile, IsAoe = true, AoERadius = aoe.AoERadius }); ecb.SetComponent(b, new BulletAnimation { LastFireTime = currTime, Speed = att.ValueRO.Speed, Length = dst, Height = att.ValueRO.Height }); ft.ValueRW.Value = currTime; st.ValueRW.AttackTimer += dly; } } else if (st.ValueRO.AttackTimer < 0) st.ValueRW.AttackTimer = 0;
        }
    }

    private static int BinarySearchX(NativeArray<MonsterPosInfo> monsterPositions, float x)
    {
        int low = 0, high = monsterPositions.Length - 1;
        while (low <= high) { int mid = (low + high) / 2; if (monsterPositions[mid].Position.x < x) low = mid + 1; else high = mid - 1; }
        return low;
    }
}